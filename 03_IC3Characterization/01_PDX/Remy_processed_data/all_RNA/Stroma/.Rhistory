library(readr)
DF <- read_delim("D:/Alexia Tlse/Data clinique/dataclinique_donnesSAMIR.csv",
";", escape_double = FALSE, trim_ws = TRUE)
View(DF)
DF$OS_time <- as.numeric(DF$OS_time)
library(readxl)
DF <- read_excel("D:/Alexia Tlse/Data clinique/dataclinique_donnesSAMIR.xlsx")
View(DF)
DF$OS_time <- as.numeric(DF$OS_time)
surv_object <- Surv(time = DF$OS_time, event = DF$OS_event)
library(survival)
library(ggplot2)
library(survminer)
surv_object <- Surv(time = DF$OS_time, event = DF$OS_event)
fit1 <- survfit(surv_object ~ Gpe, data = DF)
ggsurvplot(fit1, data = DF, pval = TRUE)
library(readxl)
DF <- read_excel("//crct-share.inserm.lan/CRCT06/Alexia/Bioinfo/Rnaseq données/PDX PacaOmics/Yvan Sauyeun/all RNA/PDX_Tumeur_Yvan_Sauyeun_all_RNA.xlsx")
View(DF)
library(readxl)
Filtre_metabo_human <- read_excel("//crct-share.inserm.lan/CRCT06/Alexia/Bioinfo/Rnaseq données/Filtre metabo human.xlsx")
View(Filtre_metabo_human)
#Créer un fichier/une liste appelé gene_ID correspondant à la colonne Gene_ID du fichier DF
gene_ID <- DF$Gene_ID
#Enlever la première colonne du fichier DF
DF <- DF[,-1]
View(DF)
#Ajouter une colonne de nom au fichier DF correspondant à la liste gene_ID
row.names(DF) <- gene_ID
#Créer un filtre métabo en prenant la première colonne du fichier Metabo
filter_metabo_human <- Filtre_metabo_human$Ensemble
#Filtrer le fichier DF avec uniquement les lignes correspondant au filtre métabo. Le nouveau fichier s'appelle DF_metabo
DF_metabo <- DF[filter_metabo_human,]
View(DF_metabo)
#Ajouter une colonne au fichier DF_metabo avec la liste du filter_metabo
row.names(DF_metabo) <- filter_metabo_human
View(DF_metabo)
setwd("//crct-share.inserm.lan/CRCT06/Alexia/Bioinfo/Rnaseq données/PDX PacaOmics/Yvan Sauyeun/all RNA/Tumeur")
#Telecharger le fichier
write.table(DF_metabo, "PDX_Yvan_Tumeur_filtre_metabo.csv", sep = "\t", dec= ".")
if(!require(ggplot2)){
install.packages("ggplot2")
library(ggplot2)
}
if(!require(grid)){
install.packages("grid")
library(grid)
}
if(!require(gridExtra)){
install.packages("gridExtra")
library(gridExtra)
}
if(!require(ggrepel)){
install.packages("ggrepel")
library(ggrepel)
}
if(!require(lemon)){
install.packages("lemon")
library(lemon)
}
if(!require(factoextra)){
install.packages("factoextra")
library(factoextra)
}
if(!require(ggplot2)){
install.packages("ggplot2")
library(ggplot2)
}
if(!require(grid)){
install.packages("grid")
library(grid)
}
if(!require(gridExtra)){
install.packages("gridExtra")
library(gridExtra)
}
if(!require(ggrepel)){
install.packages("ggrepel")
library(ggrepel)
}
if(!require(lemon)){
install.packages("lemon")
library(lemon)
}
if(!require(factoextra)){
install.packages("factoextra")
library(factoextra)
}
library(readr)
DF <- read_delim("//crct-share.inserm.lan/CRCT06/Alexia/Bioinfo/Rnaseq données/PDX PacaOmics/Yvan Sauyeun/all RNA/Tumeur/PDX_Yvan_Tumeur_filtre_metabo.csv",
";", escape_double = FALSE, na = "NA",
trim_ws = TRUE)
View(DF)
#besoin sample en ligne et observation en colonne
gene_ID <- DF[,1]
DF <- DF[,-c(1)]
DF <- as.data.frame(DF)
row.names(DF) <- as.data.frame(gene_ID)
tDF <- t(DF) #transpose la matrice
# Ou autre fonction
sil <- fviz_nbclust(tDF, kmeans, method = "silhouette") #peur remplacer "silhouette" par "wss"
#si graphe non assympotote on le fait Ã  la main
K2 <- kmeans(tDF, 2, nstart =25, iter.max=10)
K3 <- kmeans(tDF, 3, nstart =25, iter.max=10)
K4 <- kmeans(tDF, 4, nstart =25, iter.max=10)
K6 <- kmeans(tDF, 6, nstart =25, iter.max=10)
K12 <- kmeans(tDF, 12, nstart =25, iter.max=10)
str(K2)
str(K3)
str(K4)
#voilÃ  c'est calculÃ© le Kmeans
#PCA visualisation des clusters
PCA_val <- prcomp(tDF)#calcul les composant principal enregister dans un vecteur
PCA_val
str(PCA_val)
PCA_val_out <- as.data.frame(PCA_val$x)# rÃ©cupÃ¨re les PCAs en data.frame
PCA_val_out$PDX <- sapply( strsplit(as.character(row.names(tDF)), "_"), "[[", 1 ) #applique un facteur aux lignes (PDX)
#applique clusters en facteur issu du Kmeans
PCA_val_out$K2 <- sapply( strsplit(as.character(K2$cluster), "_"), "[[", 1 )
PCA_val_out$K3 <- sapply( strsplit(as.character(K3$cluster), "_"), "[[", 1 )
PCA_val_out$K4 <- sapply( strsplit(as.character(K4$cluster), "_"), "[[", 1 )
PCA_val_out$K6 <- sapply( strsplit(as.character(K6$cluster), "_"), "[[", 1 )
PCA_val_out$K12 <- sapply( strsplit(as.character(K12$cluster), "_"), "[[", 1 )
PCA_val_out
#obtenir les % des PCs
percentage <- round(PCA_val$sdev / sum(PCA_val$sdev) * 100, 2)
percentage <- paste( colnames(PCA_val_out), "(", paste( as.character(percentage), "%", ")", sep="") )
percentage
#theme couleurs de la PCA
theme <- theme(panel.background = element_blank(), #theme de la PCA Ã  faire qu'une foi
panel.border=element_rect(fill=NA),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background=element_blank(),
axis.text.x=element_text(colour="black"),
axis.text.y=element_text(colour="black"),
axis.ticks=element_line(colour="black"),
plot.margin=unit(c(1,1,1,1),"line"),
legend.position="bottom",
legend.box = "horizontal")
p2<-ggplot(PCA_val_out,aes(x=PC1,y=PC2, color=K2, label=PDX))
p3 <- ggplot(PCA_val_out,aes(x=PC1,y=PC2, color=K3, label=PDX))
p4 <- ggplot(PCA_val_out,aes(x=PC1,y=PC2, color=K4, label=PDX))
p6 <- ggplot(PCA_val_out,aes(x=PC1,y=PC2, color=K6, label=PDX))
p12 <- ggplot(PCA_val_out,aes(x=PC1,y=PC2, color=K12, label=PDX))
p2<-p2+geom_point()+ geom_text_repel(size=3)+theme+xlab(percentage[1]) + ylab(percentage[2])
p3 <- p3+geom_point()+ geom_text_repel(size=3)+theme+xlab(percentage[1]) + ylab(percentage[2])
p4 <- p4+geom_point()+ geom_text_repel(size=3)+theme+xlab(percentage[1]) + ylab(percentage[2])
p6 <- p6+geom_point()+ geom_text_repel(size=3)+theme+xlab(percentage[1]) + ylab(percentage[2])
p12 <- p12+geom_point()+ geom_text_repel(size=3)+theme+xlab(percentage[1]) + ylab(percentage[2])
triplot <- grid.arrange(sil, p2, p3, p6, nrow = 2)
#tableau grouping PDX
#!!! set working directory
write.table(PCA_val_out[,c("PDX","K2")], "PDX_group_tumeur_filtremetabo.csv", sep = "\t", dec= ".")
#tableau grouping PDX
#!!! set working directory
write.table(PCA_val_out[,c("PDX","K2")], "PDX_group_tumeur_filtremetabo.csv", sep = "\t", dec= ".")
library(readr)
DF <- read_delim("//crct-share.inserm.lan/CRCT06/Alexia/Bioinfo/Rnaseq données/PDX PacaOmics/Yvan Sauyeun/all RNA/Stroma/PDX_Yvan_Sauyeun_All_RNA_Stroma.csv",
"\t", escape_double = FALSE, trim_ws = TRUE)
View(DF)
library(readxl)
Filtre_metabo_mouse <- read_excel("//crct-share.inserm.lan/CRCT06/Alexia/Bioinfo/Rnaseq données/Filtre metabo mouse.xlsx")
View(Filtre_metabo_mouse)
#Créer un fichier/une liste appelé gene_ID correspondant à la colonne Gene_ID du fichier DF
gene_ID <- DF$Gene_ID
#Enlever la première colonne du fichier DF
DF <- DF[,-1]
View(DF)
#Ajouter une colonne de nom au fichier DF correspondant à la liste gene_ID
row.names(DF) <- gene_ID
#Créer un filtre métabo en prenant la première colonne du fichier Metabo
filter_metabo_mouse <- Filtre_metabo_mouse$`Identification gène`
#Filtrer le fichier DF avec uniquement les lignes correspondant au filtre métabo. Le nouveau fichier s'appelle DF_metabo
DF_metabo <- DF[filter_metabo_mouse,]
View(DF_metabo)
#Ajouter une colonne au fichier DF_metabo avec la liste du filter_metabo
row.names(DF_metabo) <- filter_metabo_mouse
View(DF_metabo)
setwd("//crct-share.inserm.lan/CRCT06/Alexia/Bioinfo/Rnaseq données/PDX PacaOmics/Yvan Sauyeun/all RNA/Stroma")
#Telecharger le fichier
write.table(DF_metabo, "PDX_Yvan_Stroma_filtre_metabo.csv", sep = "\t", dec= ".")
library(readr)
DF <- read_delim("//crct-share.inserm.lan/CRCT06/Alexia/Bioinfo/Rnaseq données/PDX PacaOmics/Yvan Sauyeun/all RNA/Stroma/PDX_Yvan_Stroma_filtre_metabo.csv",
";", escape_double = FALSE, trim_ws = TRUE)
View(DF)
#besoin sample en ligne et observation en colonne
gene_ID <- DF[,1]
DF <- DF[,-c(1)]
DF <- as.data.frame(DF)
row.names(DF) <- as.data.frame(gene_ID)
tDF <- t(DF) #transpose la matrice
# Ou autre fonction
sil <- fviz_nbclust(tDF, kmeans, method = "silhouette") #peur remplacer "silhouette" par "wss"
#si graphe non assympotote on le fait Ã  la main
K2 <- kmeans(tDF, 2, nstart =25, iter.max=10)
K3 <- kmeans(tDF, 3, nstart =25, iter.max=10)
K4 <- kmeans(tDF, 4, nstart =25, iter.max=10)
K6 <- kmeans(tDF, 6, nstart =25, iter.max=10)
K12 <- kmeans(tDF, 12, nstart =25, iter.max=10)
str(K2)
str(K3)
str(K4)
#voilÃ  c'est calculÃ© le Kmeans
#PCA visualisation des clusters
PCA_val <- prcomp(tDF)#calcul les composant principal enregister dans un vecteur
PCA_val
str(PCA_val)
PCA_val_out <- as.data.frame(PCA_val$x)# rÃ©cupÃ¨re les PCAs en data.frame
PCA_val_out$PDX <- sapply( strsplit(as.character(row.names(tDF)), "_"), "[[", 1 ) #applique un facteur aux lignes (PDX)
#applique clusters en facteur issu du Kmeans
PCA_val_out$K2 <- sapply( strsplit(as.character(K2$cluster), "_"), "[[", 1 )
PCA_val_out$K3 <- sapply( strsplit(as.character(K3$cluster), "_"), "[[", 1 )
PCA_val_out$K4 <- sapply( strsplit(as.character(K4$cluster), "_"), "[[", 1 )
PCA_val_out$K6 <- sapply( strsplit(as.character(K6$cluster), "_"), "[[", 1 )
PCA_val_out$K12 <- sapply( strsplit(as.character(K12$cluster), "_"), "[[", 1 )
PCA_val_out
#obtenir les % des PCs
percentage <- round(PCA_val$sdev / sum(PCA_val$sdev) * 100, 2)
percentage <- paste( colnames(PCA_val_out), "(", paste( as.character(percentage), "%", ")", sep="") )
percentage
#theme couleurs de la PCA
theme <- theme(panel.background = element_blank(), #theme de la PCA Ã  faire qu'une foi
panel.border=element_rect(fill=NA),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background=element_blank(),
axis.text.x=element_text(colour="black"),
axis.text.y=element_text(colour="black"),
axis.ticks=element_line(colour="black"),
plot.margin=unit(c(1,1,1,1),"line"),
legend.position="bottom",
legend.box = "horizontal")
p2<-ggplot(PCA_val_out,aes(x=PC1,y=PC2, color=K2, label=PDX))
p3 <- ggplot(PCA_val_out,aes(x=PC1,y=PC2, color=K3, label=PDX))
p4 <- ggplot(PCA_val_out,aes(x=PC1,y=PC2, color=K4, label=PDX))
p6 <- ggplot(PCA_val_out,aes(x=PC1,y=PC2, color=K6, label=PDX))
p12 <- ggplot(PCA_val_out,aes(x=PC1,y=PC2, color=K12, label=PDX))
p2<-p2+geom_point()+ geom_text_repel(size=3)+theme+xlab(percentage[1]) + ylab(percentage[2])
p3 <- p3+geom_point()+ geom_text_repel(size=3)+theme+xlab(percentage[1]) + ylab(percentage[2])
p4 <- p4+geom_point()+ geom_text_repel(size=3)+theme+xlab(percentage[1]) + ylab(percentage[2])
p6 <- p6+geom_point()+ geom_text_repel(size=3)+theme+xlab(percentage[1]) + ylab(percentage[2])
p12 <- p12+geom_point()+ geom_text_repel(size=3)+theme+xlab(percentage[1]) + ylab(percentage[2])
triplot <- grid.arrange(sil, p2, p3, p6, nrow = 2)
#tableau grouping PDX
#!!! set working directory
write.table(PCA_val_out[,c("PDX","K2")], "PDX_group_stroma_filtremetabo.csv", sep = "\t", dec= ".")
install.packages(c("devtools","curl")) ##Installs devtools and the MCPcounter dependancy 'curl'
library(devtools)
install_github("ebecht/MCPcounter",ref="master", subdir="Source")
load("C:/Users/alexia.brunel/Downloads/MCPcounterExampleData.RData")
View(MCPcounterExampleData)
View(MCPcounterExampleData)
load("C:/Users/alexia.brunel/Downloads/null_models.RData")
View(null_models)
View(MCPcounterExampleData)
MCPcounter.estimate=function(
expression,
featuresType=c("affy133P2_probesets","HUGO_symbols","ENTREZ_ID")[1],
probesets=read.table(curl:::curl("https://raw.githubusercontent.com/ebecht/MCPcounter/master/Signatures/probesets.txt"),sep="\t",stringsAsFactors=FALSE,colClasses="character"),
genes=read.table(curl:::curl("https://raw.githubusercontent.com/ebecht/MCPcounter/master/Signatures/genes.txt"),sep="\t",stringsAsFactors=FALSE,header=TRUE,colClasses="character",check.names=FALSE)
){
## marker.names=c("T cells","CD8 T cells","Cytotoxic lymphocytes","NK cells","B lineage","Monocytic lineage","Myeloid dendritic cells","Neutrophils","Endothelial cells","Fibroblasts")
if(featuresType=="affy133P2_probesets"){
features=probesets
markers.names = unique(features[, 2])
features=split(features[,1],features[,2])
features=lapply(features,intersect,x=rownames(expression))
features=features[sapply(features,function(x)length(x)>0)]
missing.populations=setdiff(markers.names,names(features))
features=features[intersect(markers.names,names(features))]
} else {
markersG=genes
}
if(featuresType=="HUGO_symbols"){
features=subset(markersG,get("HUGO symbols")%in%rownames(expression))
markers.names = unique(features[, "Cell population"])
features=split(features[,"HUGO symbols"],features[,"Cell population"])
missing.populations=setdiff(markers.names,names(features))
features=features[intersect(markers.names,names(features))]
}
if(featuresType=="ENTREZ_ID"){
features=subset(markersG,ENTREZID%in%rownames(expression))
markers.names = unique(features[, "Cell population"])
features=split(features[,"ENTREZID"],features[,"Cell population"])
missing.populations=setdiff(markers.names,names(features))
features=features[intersect(markers.names,names(features))]
}
if(length(missing.populations)>0){
warning(paste("Found no markers for population(s):",paste(missing.populations,collapse=", ")))
}
t(appendSignatures(expression,features))
}
test_for_infiltration=function(MCPcounterMatrix,platform=c("133P2","133A","HG1")[1]){
MCPcounterMatrix=t(MCPcounterMatrix)
params=null_models[grep(platform,colnames(null_models))]
rownames(params)=null_models[,"Cell.population"]
colnames(params)=sub(platform,"",colnames(params),fixed=T)
res=sapply(colnames(MCPcounterMatrix),function(x){
pnorm(MCPcounterMatrix[,x],mean=params[x,"mu."],sd=params[x,"sigma."],lower.tail=F)
})
rownames(res)=rownames(MCPcounterMatrix)
res
}
\name{MCPcounter.estimate}
name{MCPcounter.estimate}
name{null_models}
name(null_models)
